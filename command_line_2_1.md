# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"
- Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

Команда Linux, для работы с файлами. Встроенная в оболочку ОС. Нужна для того, чтобы была возможность сокращать пути к  открываемым файлам. Я бы её и разместил в системные команды, т.к. без неё вся работа будет идти из одной точки файловой системы. По команде 'type cd' получаю вывод 'cd is a shell builtin'. Простро встроенная команда.

- Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.

Первое что пришло на ум:
```sh
grep <string1> <some_file> > tmp.txt
grep <string2> <some_file> >> tmp.txt
grep <stringN> <some_file> >> tmp.txt
wc -l tmp.txt
rm tmp.txt
```
Но что-то подсказало, что это не тот ответ.
Почитал мануал, нашел опцию '-с' и '|', которая уже не труба конвеера, а логическое или:
```sh
grep -c 'string1|string2|stringN' <some_file>
```
Хотя возможно логическое или тоже конвеер.... Не ясно.

- Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
```sh
pstree -p | more
```
Выводит на виртуалке 'systemd'. В консоли убутны встроенной в винду 'init'.

- Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
```sh
ls 2> /dev/tty2
```

- Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
```sh
 ls 0< ptcsetup.log > pt.log
```

- Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

PTS выводит на другом терминале содержимое: 
```sh
tty
/dev/pts/2
vagrant@vagrant:~$ ls > /dev/tty3
```
Терминал PTS выводит на TTY и обратно. Как получить терминал PTY ??

- Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

Создали файловый дескриптор с номером 5 и перенаправили его вывод в STDOUT. При выполнении команды 'echo netology > /proc/$$/fd/5' мы перенаправили вывод команды echo на вход процессу файлового фескриптора. Он всё, что пришло на вход, перенаправил на свой выход, т.е. на терминал. Почему он так сделал - загадка. То, что ему определили вывод не означает, что он должен работать рестранслятором всего входого на выход.

- Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

> Note: exec №fd<&-  -закрыть файловый дескриптор
```s
bash 3>&1
ping -c 2 localhost && df -q 2>&1 > /proc/$$/fd/3 | grep invalid
```

- Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Команда выводит переменные окружения текущего пользователя. Аналогичный вывод получить можно через программы 'env' или 'printenv'
> Note: Переменные окружения (Environmental Variables) - это переменные, которые определены для текущей оболочки и наследуются любыми дочерними оболочками или процессами. Переменные окружения используются для передачи информации в процессы, которые порождаются из оболочки.

- Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.

/PROC/PID/cmdline - содержит команду с помощью которой был запущен процесс, а также переданные ей параметры
/PROC/PID/exe - ссылка на исполняемый файл

> Note: Файловая система proc состоит не только из файлов, но здесь есть и папки. Больше всего здесь папок с номерами вместо имен. Каждый этот номер означает PID процесса, а эта папка содержит информацию о каждом запущенном в системе процессе. Когда процесс заканчивается, его каталог исчезает из системы. Если открыть любой из этих каталогов в нем есть такие файлы:
ttr cpuset fdinfo mountstats stat
auxv cwd loginuid oom_adj statm
clear_refs environ maps oom_score status
cmdline exe mem root task
coredump_filter fd mounts smaps wchan
cmdline - содержит команду с помощью которой был запущен процесс, а также переданные ей параметры
cwd - символическая ссылка на текущую рабочую директорию процесса
exe - ссылка на исполняемый файл
root - ссылка на папку суперпользователя
environ - переменные окружения, доступные для процесса
fd - содержит файловые дескрипторы, файлы и устройства, которые использует процесс
maps, statm, и mem - информация о памяти процесса
stat, status - состояние процесса
С помощью этих файлов вы можете составлять различные скрипты. Например если вы хотите уничтожить все  зомби процессы, то вы можете сканировать все директории на наличие Z в файле status. Так же само можно проверить запущена ли нужная вам программа просмотрев все cmdline.

- Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

SSE 4.2
```sh
grep sse  /proc/cpuinfo
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni ssse3 cx16 pcid sse4_1 sse4_2 hypervisor lahf_lm invpcid_single pti fsgsbase invpcid md_clear flush_l1d arch_capabilities
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni ssse3 cx16 pcid sse4_1 sse4_2 hypervisor lahf_lm invpcid_single pti fsgsbase invpcid md_clear flush_l1d arch_capabilities
```

- При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:

```sh
-vagrant@netology1:~$ ssh localhost 'tty'
not a tty
```
- Почитайте, почему так происходит, и как изменить поведение.

Происходит попытка запуска ssh сессии внутри другой ssh сессии. Выделяется PTS терминал после первой ssh. Запуск виртуального терминала внутри виртуального терминала не проходит. Советуют для обхода проблемы использовать такую конструкцию:
```sh
ssh -t user@computerone.com 'ssh otheruser@computertwo.com'
```

> Note: создать скрипт 1.sh
```sh
#!/bin/bash
ssh -o "requestTTY=yes" User@ExampleHostName "cd /home/myPathFoo/myPathBar; /bin/bash"
```

- Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

порядок команд без вывода результатов:
```sh
sudo nano /proc/sys/kernel/yama/ptrace_scope (1 меняем на 0, иначе не хватит прав на передачу)
top (запустили длительный процесс)
ps -a (узнали его PID)
CTRL+Z (пауза выполнения)
bg (отправить в фон процесс)
disown top (отсоединили от трминала)
jobs -l (проверка что нет в процессах терминала)
ps -a (проверка, что есть в процессах хоста)
```
на другом терминале:
```ps
reptyr PID
```

- sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

Команда tee в Linux нужна для записи вывода любой команды в один или несколько файлов.
В конструкции 'echo string | sudo tee /root/new_file' утилита 'echo' предаёт данные на вход утилите 'tee' с правами текущего пользователя. 'tee' не использует перенаправление, которым занимается 'shell', а просто записывает свой стандартный вывод с повышенными правами в файл. Таким образом она и сработает.



--------------------------------------------------------------------------------------------------------------------------------



Здравствуйте, Алексей!

По вашим замечаниям:

Задание 2
Посмотрите за что отвечает параметр -c для grep.
```sh
Из вашего комментария не понятно, вариант 'grep -c 'string1|string2|stringN' <some_file>', который я оправлял в ДЗ, содержит pipe или нет? Формально символ присутствует, но выполняет другую функцию, на мой взгляд.
Касаемо опции '-c'
Из мануала по grep: -с  Suppress normal output; instead print a count of matching lines for each  input  file.   With  the  -v, --invert-match option (see below), count non-matching lines.
В интернет мануалах, однако, пишут, что параметр '-c' считает число вхождений шаблонов, т.е., как я понял, число повторений искомого текста. И эта версия не совпадает с информацией из man grep! Я проверил сам на ubuntu: опция '-с'написана верно в мануале операционной системы, т.е. считает сторки, а не совпадения.
Вцелом ключик изучил.
```

Задание 5
Ноль в данном примере не нужен:
ls <ptcsetup.log >pt.log
```sh
понял
```

Задание 7
Об этом рассказывает примерно на 35 минуте

Задание 8
Предлагаю посмотреть catonmat.net...part-three
Если нет времени изучать полностью, то перейдите к п. 21
```sh
ping -c 2 localhost && df -q 3>&1 1>&2 2>&3 | grep invalid
(ключ -q создаёт ошибку)
так?
хотя и мой вариант тоже работает аналогично
ping -c 2 localhost && df -q 2>&1 > /proc/$$/fd/3 | grep invalid
```

По вашему вопросу в письме - это как раз рассматривается в начале лекции.
```ps
Рассматривается. Но ответа в лекциях я не усышал. Я, кажется, не понимаю механику работы файловых дескрпторов, касательно ввода в них. Вход дескрипторов используется всеми программами для перевода их собственного вывода туда, куда завязан дескриптор? И открывая новый дескриптор мы обязаны указать куда он должен делать вывод? Ретранслятор получается. Верно описал?
```
С уважением,
Владимир.

